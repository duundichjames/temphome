<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gordian Data Juggler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #fafafa;
            color: #1d1d1f;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
            position: relative;
        }
        
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .content {
            position: relative;
            z-index: 10;
            text-align: center;
        }
        
        .main-title {
            font-size: clamp(1.8rem, 5vw, 3.2rem);
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 1rem;
            color: #1d1d1f;
        }
        
        .subtitle {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            font-weight: 200;
            color: #86868b;
            margin-bottom: 3rem;
            letter-spacing: 0.02em;
        }
        
        .nav-link {
            display: inline-block;
            font-size: 0.95rem;
            font-weight: 400;
            color: #0071e3;
            text-decoration: none;
            padding: 0.6rem 1.5rem;
            border: 1px solid rgba(0, 113, 227, 0.3);
            border-radius: 980px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .nav-link:hover {
            background: #0071e3;
            color: #fff;
            border-color: #0071e3;
        }
        
        .state-indicator {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 20;
        }
        
        .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #d2d2d7;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .dot.active {
            background: #1d1d1f;
            width: 20px;
            border-radius: 3px;
        }
        
        .hint {
            position: fixed;
            bottom: 4rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #86868b;
            letter-spacing: 0.05em;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="visualization"></canvas>
        </div>
        
        <div class="content">
            <h1 class="main-title">Gordian Data Juggler 의 세계</h1>
            <p class="subtitle">from complexity to clarity</p>
            <a href="cv.html" class="nav-link">Curriculum Vitae</a>
        </div>
    </div>
    
    <p class="hint">click to transform</p>
    
    <div class="state-indicator">
        <div class="dot active" data-state="0"></div>
        <div class="dot" data-state="1"></div>
        <div class="dot" data-state="2"></div>
    </div>

    <script>
        const canvas = document.getElementById('visualization');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let nodes = [];
        let currentState = 0;
        let transitionProgress = 1;
        let targetPositions = [];
        
        const NODE_COUNT = 80;
        const COLORS = {
            node: 'rgba(0, 113, 227, 0.6)',
            line: 'rgba(0, 113, 227, 0.08)',
            lineActive: 'rgba(0, 113, 227, 0.15)'
        };
        
        function resize() {
            width = canvas.width = window.innerWidth * 2;
            height = canvas.height = window.innerHeight * 2;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(2, 2);
        }
        
        function initNodes() {
            nodes = [];
            for (let i = 0; i < NODE_COUNT; i++) {
                nodes.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    radius: Math.random() * 2 + 1.5
                });
            }
            calculateTargetPositions();
        }
        
        // State 0: 혼돈 - 무작위 움직임
        function getChaoticPosition(node, i) {
            return {
                x: node.x + node.vx,
                y: node.y + node.vy
            };
        }
        
        // State 1: 구조화 - 그리드 패턴
        function getStructuredPosition(i) {
            const cols = Math.ceil(Math.sqrt(NODE_COUNT * window.innerWidth / window.innerHeight));
            const rows = Math.ceil(NODE_COUNT / cols);
            const cellW = window.innerWidth / (cols + 1);
            const cellH = window.innerHeight / (rows + 1);
            const col = i % cols;
            const row = Math.floor(i / cols);
            return {
                x: cellW * (col + 1),
                y: cellH * (row + 1)
            };
        }
        
        // State 2: 통찰 - 중심으로 수렴하는 나선
        function getInsightPosition(i) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const angle = (i / NODE_COUNT) * Math.PI * 6;
            const radius = (i / NODE_COUNT) * Math.min(window.innerWidth, window.innerHeight) * 0.35;
            return {
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius
            };
        }
        
        function calculateTargetPositions() {
            targetPositions = nodes.map((node, i) => {
                switch (currentState) {
                    case 0: return getChaoticPosition(node, i);
                    case 1: return getStructuredPosition(i);
                    case 2: return getInsightPosition(i);
                    default: return { x: node.x, y: node.y };
                }
            });
        }
        
        function updateNodes() {
            nodes.forEach((node, i) => {
                if (currentState === 0) {
                    // 혼돈 상태에서는 계속 움직임
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    if (node.x < 0 || node.x > window.innerWidth) node.vx *= -1;
                    if (node.y < 0 || node.y > window.innerHeight) node.vy *= -1;
                    
                    targetPositions[i] = { x: node.x, y: node.y };
                } else {
                    // 구조화된 상태로 전환
                    const target = targetPositions[i];
                    const dx = target.x - node.x;
                    const dy = target.y - node.y;
                    node.x += dx * 0.05;
                    node.y += dy * 0.05;
                }
            });
        }
        
        function drawConnections() {
            const maxDist = currentState === 0 ? 120 : currentState === 1 ? 100 : 60;
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < maxDist) {
                        const opacity = (1 - dist / maxDist) * (currentState === 2 ? 0.25 : 0.12);
                        ctx.beginPath();
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[j].x, nodes[j].y);
                        ctx.strokeStyle = `rgba(0, 113, 227, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }
        }
        
        function drawNodes() {
            nodes.forEach((node, i) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                
                const alpha = currentState === 2 ? 0.7 : 0.5;
                ctx.fillStyle = `rgba(0, 113, 227, ${alpha})`;
                ctx.fill();
            });
        }
        
        function draw() {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            updateNodes();
            drawConnections();
            drawNodes();
            requestAnimationFrame(draw);
        }
        
        function setState(state) {
            currentState = state;
            calculateTargetPositions();
            
            document.querySelectorAll('.dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === state);
            });
        }
        
        // Event Listeners
        window.addEventListener('resize', () => {
            resize();
            calculateTargetPositions();
        });
        
        canvas.addEventListener('click', () => {
            setState((currentState + 1) % 3);
        });
        
        document.querySelectorAll('.dot').forEach(dot => {
            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                setState(parseInt(dot.dataset.state));
            });
        });
        
        // Initialize
        resize();
        initNodes();
        draw();
    </script>
</body>
</html>
